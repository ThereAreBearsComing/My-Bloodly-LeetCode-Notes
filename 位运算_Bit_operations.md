# My-Bloodly-LeetCode-Notes
You Only Look Lots of Times

# 位运算 Bit operations

#### 原码:就是其二进制的表示（注意，有一位符号位）
```
00 00 00 11 -> 3
10 00 00 11 -> -3
```
#### 反码：正数的反码就是原码，负数的反码符号位不变，其余部分按位取反。
```
00 00 00 11 -> 3
11 11 11 00 -> -3
```
#### 补码：正数的补码就是原码，负数的补码是原码`+1`。
```
00 00 00 11 -> 3
11 11 11 01 -> -3
```
#### 最高位为符号位，0表示正数，1表示负数。在位运算中，符号也参与运算。

#### 2.按位的非操作～
```
~ 1 = 0
~ 0 = 1
```
`~`和`num`的补码的0和1全部取反(0变为1，1变为0)有符号整数的符号位在`~`运算中同样会取反。
```
00 00 01 01 -> 5
~
---
11 11 10 10 -> -6

11 11 10 11 -> -5
~
---
00 00 01 00 -> 4
```
#### 3.按位与操作 &
```
1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0
```
只有两个对应位都为1时才为1。
```
00 00 01 01 -> 5
&
00 00 01 10 -> 6
---
00 00 01 00 -> 4
```
#### 4.按位与操作 |
```
1 | 1 = 1
1 | 0 = 0
0 | 1 = 0
0 | 0 = 0
```
需要两个对应位都为1时才为1。
```
00 00 01 01 -> 5
&
00 00 01 10 -> 6
---
00 00 01 11 -> 7
```
#### 5.按位异或操作 ^
```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
```
需要两个对应位都不同时才为1。
```
00 00 01 01 -> 5
&
00 00 01 10 -> 6
---
00 00 00 11 -> 3
```
#### 6.按位向右移动 >>
`num >> i`将`num`的二进制表示向右移动`i`位所得的值
```
00 00 10 11 -> 11
11 >> 2
---
00 00 00 10 -> 2
```
#### 7.按位向左移动 <<
`num << i`将`num`的二进制表示向左移动`i`位所得的值
```
00 00 10 11 -> 11
11 << 3
---
01 01 10 00 -> 88
```
## 231. 2 的幂
给你一个整数`n`，请你判断该整数是否是`2`的幂次方。如果是，返回`true`；否则，返回`false`。
<br>如果存在一个整数`x`使得`n == 2x`，则认为`n`是`2`的幂次方。

#### 示例 1：
输入：n = 1
<br>输出：true
<br>解释：20 = 1

#### 示例 2：
输入：n = 16
<br>输出：true
<br>解释：24 = 16

#### 示例 3：
输入：n = 3
<br>输出：false

#### 示例 4：
输入：n = 4
<br>输出：true

#### 示例 5：
输入：n = 5
<br>输出：false

链接：https://leetcode-cn.com/problems/power-of-two

### 方法一：二进制表示
#### 思路与算法
一个数`n`是`2`的幂，当且仅当`n`是正整数，并且`n`的二进制表示中仅包含`1`个`1`。
<br>因此我们可以考虑使用位运算，将`n`的二进制表示中最低位的那个`1`提取出来，再判断剩余的数值是否为`0`即可。下面介绍两种常见的与 **「二进制表示中最低位」** 相关的位运算技巧。
#### 第一个技巧是:

<br> ***n & (n - 1)***

<br>其中 ***&*** 表示按位与运算。该位运算技巧可以直接将 ***n*** 二进制表示的最低位 ***1*** 移除，它的原理如下：
<br>假设n的二进制表示为 ***(a10⋯0)<sub>2<sub>***，其中 ***a*** 表示若干个高位，***1***表示最低位的那个 ***1***，***0⋯0***表示后面的若干个 ***0***，那么 ***n−1*** 的二进制表示为：

<br>  ***(a01⋯1)<sub>2<sub>***

<br>我们将 ***(a10⋯0)<sub>2<sub>*** 与 ***(a01⋯1)<sub>2<sub>*** 进行按位与运算，高位 ***a*** 不变，在这之后的所有位都会变为 ***0***，这样我们就将最低位的那个 ***1*** 移除了。
<br> 因此，如果 ***n*** 是正整数并且 ***n & (n - 1) = 0*** ，那么 ***n*** 就是 ***2*** 的幂。
```Python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0
```
#### 第二个技巧是
<br> ***n & (-n)***
其中 ***−n*** 是 ***n*** 的相反数，是一个负数。该位运算技巧可以直接获取 ***n*** 二进制表示的最低位的 ***1***。
由于负数是按照补码规则在计算机中存储的， ***−n*** 的二进制表示为 ***n*** 的二进制表示的每一位取反再加上 ***1***，因此它的原理如下：

假设 ***n*** 的二进制表示为 ***(a10⋯0)<sub>2</sub>***，其中 ***a*** 表示若干个高位，***1***表示最低位的那个 ***1***，***0⋯0***表示后面的若干个 ***0***，那么 ***−n*** 的二进制表示为：

<br> ***(a_bar10⋯0)<sub>2</sub> + (1)<sub>2</sub> = (a10⋯0)<sub>2</sub>***

<br>其中 ***a_bar*** 表示将 ***a*** 每一位取反。我们将 ***(a10⋯0)<sub>2</sub>*** 与 ***(a_bar10⋯0)<sub>2</sub>*** 进行按位与运算，高位全部变为 ***0***，最低位的 ***1*** 以及之后的所有 ***0*** 不变，这样我们就获取了 ***n*** 二进制表示的最低位的 ***1*** 。
<br>因此，如果 ***n*** 是正整数并且 ***n & (-n) = n***，那么 ***n*** 就是 ***2*** 的幂 。

```Python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & -n) == n
```
链接：https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode-solution-rny3/

#### 复杂度分析
* 时间复杂度：***O(1)***
* 空间复杂度：***O(1)***

### 方法二：判断是否为最大 22 的幂的约数
#### 思路与算法
除了使用二进制表示判断之外，还有一种较为取巧的做法。
<br>在题目给定的`32`位有符号整数的范围内，最大的`2`的幂为 ***2<sup>30</sup> = 1073741824*** 。我们只需要判断`n`是否是 ***2<sup>30</sup>*** 的约数即可。
```Python
class Solution:

    BIG = 2**30

    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and Solution.BIG % n == 0
```
#### 复杂度分析
* 时间复杂度：***O(1)***
* 空间复杂度：***O(1)***
